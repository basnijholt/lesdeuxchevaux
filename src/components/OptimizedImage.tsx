"use client";

import { useState, useEffect } from "react";
import { basePath, getImagePath } from "@/lib/config";

interface OptimizedImageProps {
  src: string; // Path like "/uploads/2020/07/image.jpg"
  alt: string;
  className?: string;
  priority?: boolean;
  sizes?: string;
  fill?: boolean;
  width?: number;
  height?: number;
  onClick?: () => void;
}

// Image manifest will be loaded at runtime
// In CI, this is generated by the compress-images script
// Locally, it may not exist, so we handle that gracefully
interface ImageInfo {
  blur: string;
  sizes: number[];
  originalWidth: number;
  originalHeight: number;
}

type ImageManifest = Record<string, ImageInfo>;

let manifestCache: ImageManifest | null = null;
let manifestLoading: Promise<ImageManifest | null> | null = null;

async function loadManifest(): Promise<ImageManifest | null> {
  if (manifestCache !== null) return manifestCache;
  if (manifestLoading) return manifestLoading;

  manifestLoading = fetch(`${basePath}/image-manifest.json`)
    .then((res) => (res.ok ? res.json() : null))
    .catch(() => null)
    .then((data) => {
      manifestCache = data;
      return data;
    });

  return manifestLoading;
}

// Generate srcset for responsive images
function generateSrcSet(
  src: string,
  sizes: number[],
  format: "webp" | "original"
): string {
  const ext = src.match(/\.(jpg|jpeg|png)$/i)?.[0] || ".jpg";
  const srcBasePath = src.replace(/\.(jpg|jpeg|png)$/i, "");

  return sizes
    .map((width) => {
      const suffix = format === "webp" ? ".webp" : ext;
      return `${getImagePath(srcBasePath)}-${width}w${suffix} ${width}w`;
    })
    .join(", ");
}

// Get WebP version of an image path
function getWebPPath(src: string): string {
  return getImagePath(src.replace(/\.(jpg|jpeg|png)$/i, ".webp"));
}

export function OptimizedImage({
  src,
  alt,
  className = "",
  priority = false,
  sizes = "(max-width: 640px) 640px, (max-width: 960px) 960px, (max-width: 1280px) 1280px, 1920px",
  fill = false,
  width,
  height,
  onClick,
}: OptimizedImageProps) {
  const [imageInfo, setImageInfo] = useState<ImageInfo | null>(null);
  const [isLoaded, setIsLoaded] = useState(false);
  const [useFallback, setUseFallback] = useState(false);

  useEffect(() => {
    loadManifest().then((manifest) => {
      if (manifest && manifest[src]) {
        setImageInfo(manifest[src]);
      }
    });
  }, [src]);

  const handleLoad = () => {
    setIsLoaded(true);
  };

  const handleError = () => {
    // If WebP fails, fall back to original
    setUseFallback(true);
  };

  // Build the image source
  const hasOptimizedVersions = imageInfo && imageInfo.sizes.length > 0;
  const blurStyle = imageInfo?.blur
    ? {
        backgroundImage: `url(${imageInfo.blur})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
      }
    : {};

  const containerClasses = fill
    ? `relative ${className}`
    : className;

  const imgClasses = `transition-opacity duration-300 ${
    isLoaded ? "opacity-100" : "opacity-0"
  } ${fill ? "absolute inset-0 w-full h-full object-cover" : ""}`;

  // If we have optimized versions and not falling back
  if (hasOptimizedVersions && !useFallback) {
    const webpSrcSet = generateSrcSet(src, imageInfo.sizes, "webp");
    const fallbackSrcSet = generateSrcSet(src, imageInfo.sizes, "original");

    return (
      <div
        className={containerClasses}
        style={!isLoaded ? blurStyle : undefined}
        onClick={onClick}
      >
        <picture>
          <source type="image/webp" srcSet={webpSrcSet} sizes={sizes} />
          <source srcSet={fallbackSrcSet} sizes={sizes} />
          <img
            src={getImagePath(src)}
            alt={alt}
            className={imgClasses}
            width={fill ? undefined : width || imageInfo.originalWidth}
            height={fill ? undefined : height || imageInfo.originalHeight}
            loading={priority ? "eager" : "lazy"}
            decoding={priority ? "sync" : "async"}
            onLoad={handleLoad}
            onError={handleError}
          />
        </picture>
      </div>
    );
  }

  // Fallback: just use the original image with WebP alternative
  return (
    <div
      className={containerClasses}
      style={!isLoaded && imageInfo?.blur ? blurStyle : undefined}
      onClick={onClick}
    >
      <picture>
        {!useFallback && (
          <source type="image/webp" srcSet={getWebPPath(src)} />
        )}
        <img
          src={getImagePath(src)}
          alt={alt}
          className={imgClasses}
          width={fill ? undefined : width}
          height={fill ? undefined : height}
          loading={priority ? "eager" : "lazy"}
          decoding={priority ? "sync" : "async"}
          onLoad={handleLoad}
          onError={handleError}
        />
      </picture>
    </div>
  );
}

export default OptimizedImage;
